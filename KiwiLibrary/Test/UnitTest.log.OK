'use strict' ;
/* Define Enum: Alignment */
let Alignment = {
	leading : 0,
	trailing : 1,
	fill : 2,
	center : 3
};
/* Define Enum: ApplicationKind */
let ApplicationKind = {
	terminal : 0,
	window : 1,
	operation : 2
};
/* Define Enum: Authorize */
let Authorize = {
	undetermined : 0,
	denied : 2,
	authorized : 3
};
/* Define Enum: Axis */
let Axis = {
	horizontal : 0,
	vertical : 1
};
/* Define Enum: Color */
let Color = {
	black : 0,
	red : 1,
	green : 2,
	yellow : 3,
	blue : 4,
	magenta : 5,
	cyan : 6,
	white : 7,
	min : 0,
	max : 7
};
/* Define Enum: Distribution */
let Distribution = {
	fill : 0,
	fillEqually : 1,
	equalSpacing : 2
};
/* Define Enum: ExitCode */
let ExitCode = {
	noError : 0,
	internalError : 1,
	commaneLineError : 2,
	syntaxError : 3,
	exception : 4
};
/* Define Enum: TextAlign */
let TextAlign = {
	left : 0,
	center : 2,
	right : 1,
	justfied : 3,
	normal : 4
};
/* Define Enum: TypeID */
let TypeID = {
	Undefined : 0,
	Null : 1,
	Boolean : 2,
	Number : 3,
	String : 4,
	Date : 5,
	URL : 6,
	Image : 7,
	Array : 8,
	Dictionary : 9,
	Range : 10,
	Rect : 13,
	Point : 11,
	Size : 12,
	Object : 14
};
/**
 * Debug.js
 */

function checkVariables(place, ...vars)
{
	let result = true ;
	vars.forEach(function(value, index){
	    if(isUndefined(value)){
		     console.log("check at " + place + ": Undefined at index " + index + "\n") ;
		     result = false ;
	    } else if(isNull(value)) {
		     console.log("check at " + place + ": Null at index " + index + "\n") ;
		     result = false ;
	    }
	}) ;
	return result ;
}
/* Math.js */

/* randomInt: Get random integer value between min and max */
Math.randomInt = function(min, max) {
  const range = max - min + 1 ;
  const rval  = Math.floor(Math.random() * range) ;
  return rval + min ;
}
/*
 * SpriteAction.js
 */

class SpriteNodeAction
{
	constructor(speed, angle){
		checkVariables("SpriteNodeAction.constructor", speed, angle) ;
		this.mSpeed	= speed ;	// Double [m/sec]
		this.mAngle	= angle ;	// Double [radian]
	}
	get speed()	{ return this.mSpeed ;		}
	get angle()	{ return this.mAngle ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			speed: 		this.mSpeed,
			angle: 		this.mAngle
		} ;
		return obj ;
	}
}
/*
 * SpriteStatus.js
 */

class SpriteNodeStatus
{
	// constructor(name: String, teamid:Int, pos:Point, size:Size, energy: Double)
	constructor(name, tid, pos, size, energy){
		checkVariables("SpriteNodeStatus.constructor", name, tid, pos, size, energy) ;
		this.mName      = name ;
		this.mTeamId    = tid ;
		this.mPosition	= pos ;
		this.mSize	= size ;
		this.mEnergy	= energy ;
	}
	get name()      { return this.mName ;		}
	get teamId()    { return this.mTeamId ;		}
	get position()	{ return this.mPosition ;	}
	get size()	{ return this.mSize ;		}
	get energy()    { return this.mEnergy ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			name:		this.mName,
			teamId:		this.mTeamId,
			position:	this.mPosition,
			size:		this.mSize,
			energy:		this.mEnergy
		} ;
		return obj ;
	}
}
/*
 * SpriteCondition.js
 */

class SpriteCondition {
	constructor(cdamage){
		checkVariables("SpriteCondition.constructor", cdamage)
		this.mCollisionDamage = cdamage ;
	}

	// collosionDamage -> Double
	get collisionDamage() { return this.mCollisionDamage ; }
	set collisionDamage(newval) {
		if(checkVariables(newval)) {
			this.mCollisionDamage = newval ;
		}
	}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			collisionDamage: this.mCollisionDamage
		} ;
		return obj ;
	}
}
  -> Compiler: OK
/* Unit test for Type operation */
* Test: JSValue(bool):
type = bool
native: 1
native -> js: 1
duplicate: 1
* Test: JSValue(Int32):
type = number
native: 1
native -> js: 1
duplicate: 1
* Test: JSValue(Double):
type = number
native: 1.23
native -> js: 1.23
duplicate: 1.23
* Test: JSValue(String):
type = string
native: "Hello, world"
native -> js: "Hello, world"
duplicate: "Hello, world"
* Test: JSValue(Date):
type = date
native: 1970-01-01 00:00:00 +0000
native -> js: 1970-01-01 00:00:00 +0000
duplicate: 1970-01-01 00:00:00 +0000
* Test: JSValue(URL):
type = URL
native: https://github.com/steelwheels
native -> js: https://github.com/steelwheels
duplicate: https://github.com/steelwheels
* Test: JSValue(Image):
type = image
native: {image: name:<unknown>, size:0.0 x 0.0}
native -> js: {image: name:<unknown>, size:0.0 x 0.0}
duplicate: {image: name:<unknown>, size:0.0 x 0.0}
* Test: JSValue(Array):
type = array
native: [
  1
  1
  1.23
  "Hello, world"
  1970-01-01 00:00:00 +0000
  https://github.com/steelwheels
  {image: name:<unknown>, size:0.0 x 0.0}
]
native -> js: [
  1
  1
  1.23
  "Hello, world"
  1970-01-01 00:00:00 +0000
  https://github.com/steelwheels
  {image: name:<unknown>, size:0.0 x 0.0}
]
duplicate: [
  1
  1
  1.23
  "Hello, world"
  1970-01-01 00:00:00 +0000
  https://github.com/steelwheels
  {image: name:<unknown>, size:0.0 x 0.0}
]
* Test: JSValue(Dictionary):
type = dictionary
native: {
  bool: 1
  date: 1970-01-01 00:00:00 +0000
  double: 1.23
  image: {image: name:<unknown>, size:0.0 x 0.0}
  int32: 1
  string: "Hello, world"
  url: https://github.com/steelwheels
}
native -> js: {
  bool: 1
  date: 1970-01-01 00:00:00 +0000
  double: 1.23
  image: {image: name:<unknown>, size:0.0 x 0.0}
  int32: 1
  string: "Hello, world"
  url: https://github.com/steelwheels
}
duplicate: {
  bool: 1
  date: 1970-01-01 00:00:00 +0000
  double: 1.23
  image: {image: name:<unknown>, size:0.0 x 0.0}
  int32: 1
  string: "Hello, world"
  url: https://github.com/steelwheels
}
* Test: JSValue(Range):
type = range
native: {10, 3}
native -> js: {10, 3}
duplicate: {10, 3}
* Test: JSValue(Point):
type = point
native: {x:1.0, y:2.0}
native -> js: {x:1.0, y:2.0}
duplicate: {x:1.0, y:2.0}
* Test: JSValue(Size):
type = size
native: {width:3.0, height:4.0}
native -> js: {width:3.0, height:4.0}
duplicate: {width:3.0, height:4.0}
* Test: JSValue(Rect):
type = rect
native: {origin:{x:1.0, y:2.0}, size:{width:3.0, height:4.0}}
native -> js: {origin:{x:1.0, y:2.0}, size:{width:3.0, height:4.0}}
duplicate: {origin:{x:1.0, y:2.0}, size:{width:3.0, height:4.0}}
/* Unit test for Math operation */
sqrt(4.0) = 2.0
/* Unit test for Database */
read(d0) -> 1234
write(d2, -5) -> 1
read(d2) -> -5
/* Unit test for Operation */
// Allocate operation
'use strict' ;
/* Define Enum: Alignment */
let Alignment = {
	leading : 0,
	trailing : 1,
	fill : 2,
	center : 3
};
/* Define Enum: ApplicationKind */
let ApplicationKind = {
	terminal : 0,
	window : 1,
	operation : 2
};
/* Define Enum: Authorize */
let Authorize = {
	undetermined : 0,
	denied : 2,
	authorized : 3
};
/* Define Enum: Axis */
let Axis = {
	horizontal : 0,
	vertical : 1
};
/* Define Enum: Color */
let Color = {
	black : 0,
	red : 1,
	green : 2,
	yellow : 3,
	blue : 4,
	magenta : 5,
	cyan : 6,
	white : 7,
	min : 0,
	max : 7
};
/* Define Enum: Distribution */
let Distribution = {
	fill : 0,
	fillEqually : 1,
	equalSpacing : 2
};
/* Define Enum: ExitCode */
let ExitCode = {
	noError : 0,
	internalError : 1,
	commaneLineError : 2,
	syntaxError : 3,
	exception : 4
};
/* Define Enum: TextAlign */
let TextAlign = {
	left : 0,
	center : 2,
	right : 1,
	justfied : 3,
	normal : 4
};
/* Define Enum: TypeID */
let TypeID = {
	Undefined : 0,
	Null : 1,
	Boolean : 2,
	Number : 3,
	String : 4,
	Date : 5,
	URL : 6,
	Image : 7,
	Array : 8,
	Dictionary : 9,
	Range : 10,
	Rect : 13,
	Point : 11,
	Size : 12,
	Object : 14
};
/**
 * Debug.js
 */

function checkVariables(place, ...vars)
{
	let result = true ;
	vars.forEach(function(value, index){
	    if(isUndefined(value)){
		     console.log("check at " + place + ": Undefined at index " + index + "\n") ;
		     result = false ;
	    } else if(isNull(value)) {
		     console.log("check at " + place + ": Null at index " + index + "\n") ;
		     result = false ;
	    }
	}) ;
	return result ;
}
/* Math.js */

/* randomInt: Get random integer value between min and max */
Math.randomInt = function(min, max) {
  const range = max - min + 1 ;
  const rval  = Math.floor(Math.random() * range) ;
  return rval + min ;
}
/*
 * SpriteAction.js
 */

class SpriteNodeAction
{
	constructor(speed, angle){
		checkVariables("SpriteNodeAction.constructor", speed, angle) ;
		this.mSpeed	= speed ;	// Double [m/sec]
		this.mAngle	= angle ;	// Double [radian]
	}
	get speed()	{ return this.mSpeed ;		}
	get angle()	{ return this.mAngle ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			speed: 		this.mSpeed,
			angle: 		this.mAngle
		} ;
		return obj ;
	}
}
/*
 * SpriteStatus.js
 */

class SpriteNodeStatus
{
	// constructor(name: String, teamid:Int, pos:Point, size:Size, energy: Double)
	constructor(name, tid, pos, size, energy){
		checkVariables("SpriteNodeStatus.constructor", name, tid, pos, size, energy) ;
		this.mName      = name ;
		this.mTeamId    = tid ;
		this.mPosition	= pos ;
		this.mSize	= size ;
		this.mEnergy	= energy ;
	}
	get name()      { return this.mName ;		}
	get teamId()    { return this.mTeamId ;		}
	get position()	{ return this.mPosition ;	}
	get size()	{ return this.mSize ;		}
	get energy()    { return this.mEnergy ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			name:		this.mName,
			teamId:		this.mTeamId,
			position:	this.mPosition,
			size:		this.mSize,
			energy:		this.mEnergy
		} ;
		return obj ;
	}
}
/*
 * SpriteCondition.js
 */

class SpriteCondition {
	constructor(cdamage){
		checkVariables("SpriteCondition.constructor", cdamage)
		this.mCollisionDamage = cdamage ;
	}

	// collosionDamage -> Double
	get collisionDamage() { return this.mCollisionDamage ; }
	set collisionDamage(newval) {
		if(checkVariables(newval)) {
			this.mCollisionDamage = newval ;
		}
	}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			collisionDamage: this.mCollisionDamage
		} ;
		return obj ;
	}
}
/*
 * Operation.js : Define Operation class
 */

 class CancelException extends Error
 {
 	constructor (code){
 		super("CancelException") ;
 		this.code = code ;
 	}
 }

function _cancel() {
	throw new CancelException(ExitCode.exception) ;
}

/* This class must be inherited */
class Operation
{
	constructor(){
		this.parameters = {} ;
	}

	setParameter(name, value){
		this.parameters[name] = value ;
	}

	parameter(name){
		return this.parameters[name] ;
	}

	main(){
		try {
			this.execute() ;
		} catch(err){
			return err.code
		}
	}

	execute(){
		console.log("[Error] Operation.execute must be override\n") ;
		return 0 ;
	}

	cancel(){
		_cancel() ;
	}
}

function _set_operation(op, name, value)
{
	op.setParameter(name, value) ;
}

function _get_operation(op, name)
{
	return op.parameter(name) ;
}

function _exec_operation(op)
{
	op.main() ;
}

/* unit-test-0.js */

class Task extends Operation
{
	execute(){
		console.log("Task: Hello, World !!\n") ;
	}
}

operation = new Task() ;

// Set input
// Get input
Input value: 1.23
// Execute the operation
// Wait operations are finished
Task: Hello, World !!
/* Unit test for Operation2 */
'use strict' ;
/* Define Enum: Alignment */
let Alignment = {
	leading : 0,
	trailing : 1,
	fill : 2,
	center : 3
};
/* Define Enum: ApplicationKind */
let ApplicationKind = {
	terminal : 0,
	window : 1,
	operation : 2
};
/* Define Enum: Authorize */
let Authorize = {
	undetermined : 0,
	denied : 2,
	authorized : 3
};
/* Define Enum: Axis */
let Axis = {
	horizontal : 0,
	vertical : 1
};
/* Define Enum: Color */
let Color = {
	black : 0,
	red : 1,
	green : 2,
	yellow : 3,
	blue : 4,
	magenta : 5,
	cyan : 6,
	white : 7,
	min : 0,
	max : 7
};
/* Define Enum: Distribution */
let Distribution = {
	fill : 0,
	fillEqually : 1,
	equalSpacing : 2
};
/* Define Enum: ExitCode */
let ExitCode = {
	noError : 0,
	internalError : 1,
	commaneLineError : 2,
	syntaxError : 3,
	exception : 4
};
/* Define Enum: TextAlign */
let TextAlign = {
	left : 0,
	center : 2,
	right : 1,
	justfied : 3,
	normal : 4
};
/* Define Enum: TypeID */
let TypeID = {
	Undefined : 0,
	Null : 1,
	Boolean : 2,
	Number : 3,
	String : 4,
	Date : 5,
	URL : 6,
	Image : 7,
	Array : 8,
	Dictionary : 9,
	Range : 10,
	Rect : 13,
	Point : 11,
	Size : 12,
	Object : 14
};
/**
 * Debug.js
 */

function checkVariables(place, ...vars)
{
	let result = true ;
	vars.forEach(function(value, index){
	    if(isUndefined(value)){
		     console.log("check at " + place + ": Undefined at index " + index + "\n") ;
		     result = false ;
	    } else if(isNull(value)) {
		     console.log("check at " + place + ": Null at index " + index + "\n") ;
		     result = false ;
	    }
	}) ;
	return result ;
}
/* Math.js */

/* randomInt: Get random integer value between min and max */
Math.randomInt = function(min, max) {
  const range = max - min + 1 ;
  const rval  = Math.floor(Math.random() * range) ;
  return rval + min ;
}
/*
 * SpriteAction.js
 */

class SpriteNodeAction
{
	constructor(speed, angle){
		checkVariables("SpriteNodeAction.constructor", speed, angle) ;
		this.mSpeed	= speed ;	// Double [m/sec]
		this.mAngle	= angle ;	// Double [radian]
	}
	get speed()	{ return this.mSpeed ;		}
	get angle()	{ return this.mAngle ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			speed: 		this.mSpeed,
			angle: 		this.mAngle
		} ;
		return obj ;
	}
}
/*
 * SpriteStatus.js
 */

class SpriteNodeStatus
{
	// constructor(name: String, teamid:Int, pos:Point, size:Size, energy: Double)
	constructor(name, tid, pos, size, energy){
		checkVariables("SpriteNodeStatus.constructor", name, tid, pos, size, energy) ;
		this.mName      = name ;
		this.mTeamId    = tid ;
		this.mPosition	= pos ;
		this.mSize	= size ;
		this.mEnergy	= energy ;
	}
	get name()      { return this.mName ;		}
	get teamId()    { return this.mTeamId ;		}
	get position()	{ return this.mPosition ;	}
	get size()	{ return this.mSize ;		}
	get energy()    { return this.mEnergy ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			name:		this.mName,
			teamId:		this.mTeamId,
			position:	this.mPosition,
			size:		this.mSize,
			energy:		this.mEnergy
		} ;
		return obj ;
	}
}
/*
 * SpriteCondition.js
 */

class SpriteCondition {
	constructor(cdamage){
		checkVariables("SpriteCondition.constructor", cdamage)
		this.mCollisionDamage = cdamage ;
	}

	// collosionDamage -> Double
	get collisionDamage() { return this.mCollisionDamage ; }
	set collisionDamage(newval) {
		if(checkVariables(newval)) {
			this.mCollisionDamage = newval ;
		}
	}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			collisionDamage: this.mCollisionDamage
		} ;
		return obj ;
	}
}
MainThread: Compile OK
'use strict' ;
/* Define Enum: Alignment */
let Alignment = {
	leading : 0,
	trailing : 1,
	fill : 2,
	center : 3
};
/* Define Enum: ApplicationKind */
let ApplicationKind = {
	terminal : 0,
	window : 1,
	operation : 2
};
/* Define Enum: Authorize */
let Authorize = {
	undetermined : 0,
	denied : 2,
	authorized : 3
};
/* Define Enum: Axis */
let Axis = {
	horizontal : 0,
	vertical : 1
};
/* Define Enum: Color */
let Color = {
	black : 0,
	red : 1,
	green : 2,
	yellow : 3,
	blue : 4,
	magenta : 5,
	cyan : 6,
	white : 7,
	min : 0,
	max : 7
};
/* Define Enum: Distribution */
let Distribution = {
	fill : 0,
	fillEqually : 1,
	equalSpacing : 2
};
/* Define Enum: ExitCode */
let ExitCode = {
	noError : 0,
	internalError : 1,
	commaneLineError : 2,
	syntaxError : 3,
	exception : 4
};
/* Define Enum: TextAlign */
let TextAlign = {
	left : 0,
	center : 2,
	right : 1,
	justfied : 3,
	normal : 4
};
/* Define Enum: TypeID */
let TypeID = {
	Undefined : 0,
	Null : 1,
	Boolean : 2,
	Number : 3,
	String : 4,
	Date : 5,
	URL : 6,
	Image : 7,
	Array : 8,
	Dictionary : 9,
	Range : 10,
	Rect : 13,
	Point : 11,
	Size : 12,
	Object : 14
};
/**
 * Debug.js
 */

function checkVariables(place, ...vars)
{
	let result = true ;
	vars.forEach(function(value, index){
	    if(isUndefined(value)){
		     console.log("check at " + place + ": Undefined at index " + index + "\n") ;
		     result = false ;
	    } else if(isNull(value)) {
		     console.log("check at " + place + ": Null at index " + index + "\n") ;
		     result = false ;
	    }
	}) ;
	return result ;
}
/* Math.js */

/* randomInt: Get random integer value between min and max */
Math.randomInt = function(min, max) {
  const range = max - min + 1 ;
  const rval  = Math.floor(Math.random() * range) ;
  return rval + min ;
}
/*
 * SpriteAction.js
 */

class SpriteNodeAction
{
	constructor(speed, angle){
		checkVariables("SpriteNodeAction.constructor", speed, angle) ;
		this.mSpeed	= speed ;	// Double [m/sec]
		this.mAngle	= angle ;	// Double [radian]
	}
	get speed()	{ return this.mSpeed ;		}
	get angle()	{ return this.mAngle ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			speed: 		this.mSpeed,
			angle: 		this.mAngle
		} ;
		return obj ;
	}
}
/*
 * SpriteStatus.js
 */

class SpriteNodeStatus
{
	// constructor(name: String, teamid:Int, pos:Point, size:Size, energy: Double)
	constructor(name, tid, pos, size, energy){
		checkVariables("SpriteNodeStatus.constructor", name, tid, pos, size, energy) ;
		this.mName      = name ;
		this.mTeamId    = tid ;
		this.mPosition	= pos ;
		this.mSize	= size ;
		this.mEnergy	= energy ;
	}
	get name()      { return this.mName ;		}
	get teamId()    { return this.mTeamId ;		}
	get position()	{ return this.mPosition ;	}
	get size()	{ return this.mSize ;		}
	get energy()    { return this.mEnergy ;		}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			name:		this.mName,
			teamId:		this.mTeamId,
			position:	this.mPosition,
			size:		this.mSize,
			energy:		this.mEnergy
		} ;
		return obj ;
	}
}
/*
 * SpriteCondition.js
 */

class SpriteCondition {
	constructor(cdamage){
		checkVariables("SpriteCondition.constructor", cdamage)
		this.mCollisionDamage = cdamage ;
	}

	// collosionDamage -> Double
	get collisionDamage() { return this.mCollisionDamage ; }
	set collisionDamage(newval) {
		if(checkVariables(newval)) {
			this.mCollisionDamage = newval ;
		}
	}

	// toParameter() -> Object
	toParameter() {
		let obj = {
			collisionDamage: this.mCollisionDamage
		} ;
		return obj ;
	}
}
/*
 * Operation.js : Define Operation class
 */

 class CancelException extends Error
 {
 	constructor (code){
 		super("CancelException") ;
 		this.code = code ;
 	}
 }

function _cancel() {
	throw new CancelException(ExitCode.exception) ;
}

/* This class must be inherited */
class Operation
{
	constructor(){
		this.parameters = {} ;
	}

	setParameter(name, value){
		this.parameters[name] = value ;
	}

	parameter(name){
		return this.parameters[name] ;
	}

	main(){
		try {
			this.execute() ;
		} catch(err){
			return err.code
		}
	}

	execute(){
		console.log("[Error] Operation.execute must be override\n") ;
		return 0 ;
	}

	cancel(){
		_cancel() ;
	}
}

function _set_operation(op, name, value)
{
	op.setParameter(name, value) ;
}

function _get_operation(op, name)
{
	return op.parameter(name) ;
}

function _exec_operation(op)
{
	op.main() ;
}

/* unit-test-1.js */

class Machine extends Operation
{
	execute(){
		console.log("[Machine] Hello, world\n");
	}
} ;

operation = new Machine() ;

MainThread: [Compile] OK
* Test1
MainThread: Set command: param0 <- 1
* Test3
MainThread: Set command: param2 <- {image: name:<unknown>, size:0.0 x 0.0}
* Test5
exec result: OK
[Machine] Hello, world
Summary: OK
[UnitTest]

